## Definition

The term observability finds its origins in control theory, where it refers to the ability to infer a function of the system state from the output. (Krauss et al., 2025). 

Within software, this definition is adapted as "visibility into the behavior, performance and health of the layers within a software ecosystem". This ecosystem can encompass everything from user interfaces to backend services, databases, infrastructures and the networks that connect them. (Kisina et al., 2021)

Observability within networking might mean the following:
- monitoring the health and reachability of individual components, such as routers and switches
- logging incoming requests
- following important metrics - network speed, packet time-to-live (TTL), data loss across the network

Combined with effective alerting (further described in chapter TODO), this can lead to early detection of anomalous behavior - packet loss in a certain part of the network might indicate faulty equipment, massive increase in incoming requests might point to an incoming distributed denial of service (DDoS) attack.

The field that has come to be best associated with ensuring observability and monitoring is called Site Reliability Engineering, also known as SRE. The origins of this term can be traced to Google, where the first SRE team was established in 2003. (Treynor, 2014)


## DevOps and SRE

Historically, software development used to be split into Development and Operations (shortened to Dev and Ops respectively). While Dev was tasked with creating new features for the software and updating them, the actual deployment to the servers and their ongoing maintenance was left to Ops. This has caused a fracture or outright resentment between the teams, who viewed each other as enemies, rather than colleagues working towards a common goal. 

To streamline the deployment process and assure stable development, a new culture began to emerge in the late 2010s, called *DevOps*. DevOps attempts to bridge the gap between Development and Operations and connects the two teams together. That way, development teams take part in deployment and operations play an active role in development.

The term would further develop into the 2020s, and as of time of this thesis the term is at a sharp all-time high. 

Many critics warn that DevOps has steered too far away from it's original purpose, with DevOps becoming it's own discipline, rather than a culture bridging two cooperating disciplines. 

Developers who describe themselves as "DevOps" now make up 2.5% of the workforce, according to the latest StackOverflow developer survey. This marks a large increase from the 1.3% reported in 2015.


## Costs and Benefits
# Problems with auto-scaling systems

Many software projects utilize *virtualization*, which allows for software to run on virtual machines or containers. This process, combined with cloud hosting, allows for automated scaling of memory / disk-space available to the application based on its current needs. If an application is running out of memory during intensive operations, it is trivial to add more processing cores and RAM. 

Such scaling can be done manually, but more and more often this scaling is automated and can respond within seconds to increased demand. This is done to make sure the application works correctly even during unusually high traffic, such as during specific holidays or limited sales. 

However, these resources come at a cost. A program which incorrectly or inefficiently utilizes space or memory might lead to exorbitant costs to the business. It is very often difficult to catch such inefficiencies, as finding out which process takes too much time or runs inefficiently requires an in-depth understanding of the system.

This is where observability can be most useful, as all aspects of the system can be recorded and analyzed for inefficiencies. The process of analyzing such system traces for space or time complexity is called *profiling*, and allows the developer to figure out, where the program spends most of it's runtime / memory. 

Common pitfalls might include inefficient database reads or calculation algorithms. When reading from a database, such as to retrieve a username, it is often inefficient to go element by element. Instead, correct indexing and search algorithms can be used to access the user much faster, which places less of a pressure on the system itself. 

The problem with these inefficiencies is that they often only show up at a large scale. Different algorithms can have different properties in regards to the length of runtime based on the number of elements.










---

Krauss, I., Lopez, V. G., & Müller, M. A. (2025). On sample-based functional observability of linear systems. _IEEE Control Systems Letters_, _9_, 1393–1398. [https://doi.org/10.1109/LCSYS.2025.3582512](https://doi.org/10.1109/LCSYS.2025.3582512)

Kisina, D., Akpe, O.-E. E., Owoade, S., Ubanadu, B. C., Gbenle, T. P., & Adanigbo, O. S. (2021). _A Conceptual Framework for Full-Stack Observability in Modern Distributed Software Systems_. _4_(10). [https://www.irejournals.com/formatedpaper/1708126.pdf](https://www.irejournals.com/formatedpaper/1708126.pdf)

Treynor, B. (2014). _Keys to SRE_. [https://www.usenix.org/conference/srecon14/technical-sessions/presentation/keys-sre](https://www.usenix.org/conference/srecon14/technical-sessions/presentation/keys-sre)